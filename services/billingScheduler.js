import cron from 'node-cron';
import PGResident from '../models/PGResident.js';
import Invoice from '../models/Invoice.js';
import { generateInvoicePDF, sendInvoiceEmail } from '../controllers/invoiceController.js';
import { calculateAnniversaryBilling, } from './billingService.js';

class BillingScheduler {
  constructor() {
    this.jobs = new Map();
    this.isInitialized = false;
  }

  // Initialize all cron jobs
  async initialize() {
    if (this.isInitialized) {
      console.log('Billing scheduler already initialized');
      return;
    }

    try {
      // Daily check for upcoming bills (runs at 9 AM every day)
      this.scheduleJob('daily-billing-check', '0 9 * * *', this.checkUpcomingBills.bind(this));
      
      // Weekly reminder for unpaid invoices (runs at 10 AM every Monday)
      this.scheduleJob('weekly-reminders', '0 10 * * 1', this.sendPaymentReminders.bind(this));
      
      // Monthly billing generation (runs at 8 AM on 1st of every month)
      this.scheduleJob('monthly-billing', '0 8 1 * *', this.generateMonthlyBilling.bind(this));
      
      // Daily overdue payment check (runs at 11 AM every day)
      this.scheduleJob('overdue-check', '0 11 * * *', this.checkOverduePayments.bind(this));

      this.isInitialized = true;
      console.log('Billing scheduler initialized successfully');
    } catch (error) {
      console.error('Error initializing billing scheduler:', error);
      throw error;
    }
  }

  // Schedule a cron job
  scheduleJob(name, schedule, task) {
    if (this.jobs.has(name)) {
      return;
    }

    const job = cron.schedule(schedule, async () => {
      try {
        await task();
      } catch (error) {
        console.error(`Error in job ${name}:`, error);
      }
    }, {
      scheduled: true,
      timezone: "Asia/Kolkata"
    });

    this.jobs.set(name, job);
  }

  // Check for upcoming bills (anniversary-based)
  async checkUpcomingBills() {
    try {
      const today = new Date();
      const threeDaysFromNow = new Date(today.getTime() + (3 * 24 * 60 * 60 * 1000));

      // Find tenants whose next billing date is within 3 days
      const upcomingBills = await PGResident.find({
        status: 'active',
        nextBillingDate: {
          $gte: today,
          $lte: threeDaysFromNow
        }
      }).populate('pgId roomId');

      console.log(`Found ${upcomingBills.length} upcoming bills`);

      for (const resident of upcomingBills) {
        try {
          // Check if anniversary billing is due today
          const billingDate = new Date(resident.nextBillingDate);
          if (billingDate.toDateString() === today.toDateString()) {
            await this.generateAnniversaryInvoice(resident);
          } else {
            // Send reminder for upcoming billing
            await this.sendBillingReminder(resident, billingDate);
          }
        } catch (error) {
          console.error(`Error processing billing for resident ${resident._id}:`, error);
        }
      }
    } catch (error) {
      console.error('Error in checkUpcomingBills:', error);
    }
  }

  // Generate anniversary-based invoice
  async generateAnniversaryInvoice(resident) {
    try {
      const billingData = await calculateAnniversaryBilling(resident);
      
      const invoiceData = {
        tenantId: resident._id,
        roomId: resident.roomId,
        pgId: resident.pgId,
        type: 'rent',
        amount: billingData.totalAmount,
        description: `Monthly rent for ${resident.roomId?.room_number || 'Room'} - Anniversary billing`,
        dueDate: new Date(Date.now() + (7 * 24 * 60 * 60 * 1000)), // 7 days from now
        billingPeriod: {
          start: billingData.billingPeriod.start,
          end: billingData.billingPeriod.end
        },
        items: billingData.items,
        metadata: {
          billingType: 'anniversary',
          anniversaryDate: resident.checkinDate,
          isAutoGenerated: true
        }
      };

      const invoice = new Invoice(invoiceData);
      await invoice.save();

      // Update resident's next billing date
      const nextBillingDate = new Date(resident.nextBillingDate);
      nextBillingDate.setMonth(nextBillingDate.getMonth() + 1);
      
      await PGResident.findByIdAndUpdate(resident._id, {
        lastBillingDate: resident.nextBillingDate,
        nextBillingDate: nextBillingDate,
        $push: {
          billingHistory: {
            invoiceId: invoice._id,
            amount: invoice.amount,
            billingDate: new Date(),
            type: 'anniversary'
          }
        }
      });

      // Generate PDF and send email
      await generateInvoicePDF(invoice._id);
      await sendInvoiceEmail(invoice._id);

      console.log(`Anniversary invoice generated for resident ${resident._id}, invoice ${invoice._id}`);
    } catch (error) {
      console.error(`Error generating anniversary invoice for resident ${resident._id}:`, error);
    }
  }

  // Send billing reminder
  async sendBillingReminder(resident, billingDate) {
    try {
      const daysUntilBilling = Math.ceil((billingDate - new Date()) / (24 * 60 * 60 * 1000));
      
      // Import email service
      const { sendEmail } = await import('../modules/email/index.js');
      
      const emailData = {
        to: resident.email,
        subject: `Upcoming Rent Bill - ${daysUntilBilling} days remaining`,
        template: 'billing-reminder',
        context: {
          tenantName: resident.name,
          roomNumber: resident.roomId?.room_number || 'Your Room',
          pgName: resident.pgId?.pg_name || 'PG',
          billingDate: billingDate.toDateString(),
          daysUntilBilling,
          rentAmount: resident.rentAmount || 0
        }
      };

      await sendEmail(emailData);
      console.log(`Billing reminder sent to ${resident.email}`);
    } catch (error) {
      console.error(`Error sending billing reminder to ${resident._id}:`, error);
    }
  }

  // Send payment reminders for unpaid invoices
  async sendPaymentReminders() {
    try {
      const unpaidInvoices = await Invoice.find({
        status: 'pending',
        dueDate: { $lt: new Date() }
      }).populate('tenantId pgId roomId');

      console.log(`Found ${unpaidInvoices.length} unpaid invoices`);

      for (const invoice of unpaidInvoices) {
        try {
          const daysOverdue = Math.ceil((new Date() - invoice.dueDate) / (24 * 60 * 60 * 1000));
          
          // Import email service
          const { sendEmail } = await import('../modules/email/index.js');
          
          const emailData = {
            to: invoice.tenantId?.email,
            subject: `Payment Reminder - Invoice ${invoice.invoiceNumber} (${daysOverdue} days overdue)`,
            template: 'payment-reminder',
            context: {
              tenantName: invoice.tenantId?.name,
              invoiceNumber: invoice.invoiceNumber,
              amount: invoice.amount,
              dueDate: invoice.dueDate.toDateString(),
              daysOverdue,
              pgName: invoice.pgId?.pg_name || 'PG'
            }
          };

          await sendEmail(emailData);
          console.log(`Payment reminder sent for invoice ${invoice._id}`);
        } catch (error) {
          console.error(`Error sending payment reminder for invoice ${invoice._id}:`, error);
        }
      }
    } catch (error) {
      console.error('Error in sendPaymentReminders:', error);
    }
  }

  // Generate monthly billing (for electricity and common charges)
  async generateMonthlyBilling() {
    try {
      const activeResidents = await PGResident.find({
        status: 'active'
      }).populate('pgId roomId');

      console.log(`Processing monthly billing for ${activeResidents.length} active residents`);

      for (const resident of activeResidents) {
        try {
          // Generate electricity bill if applicable
          await this.generateElectricityBill(resident);
          
          // Generate common charges if applicable
          await this.generateCommonCharges(resident);
        } catch (error) {
          console.error(`Error in monthly billing for resident ${resident._id}:`, error);
        }
      }
    } catch (error) {
      console.error('Error in generateMonthlyBilling:', error);
    }
  }

  // Generate electricity bill
  async generateElectricityBill(resident) {
    try {
      // Check if there's an existing electricity bill for this month
      const currentMonth = new Date().getMonth();
      const currentYear = new Date().getFullYear();
      
      const existingBill = await Invoice.findOne({
        tenantId: resident._id,
        type: 'electricity',
        'billingPeriod.start': {
          $gte: new Date(currentYear, currentMonth, 1),
          $lt: new Date(currentYear, currentMonth + 1, 1)
        }
      });

      if (existingBill) {
        console.log(`Electricity bill already exists for resident ${resident._id} for current month`);
        return;
      }

      // Calculate electricity charges (this would integrate with your existing electricity billing)
      const electricityAmount = await this.calculateElectricityCharges(resident);
      
      if (electricityAmount > 0) {
        const invoiceData = {
          tenantId: resident._id,
          roomId: resident.roomId,
          pgId: resident.pgId,
          type: 'electricity',
          amount: electricityAmount,
          description: `Electricity charges for ${new Date().toLocaleString('default', { month: 'long', year: 'numeric' })}`,
          dueDate: new Date(Date.now() + (15 * 24 * 60 * 60 * 1000)), // 15 days from now
          billingPeriod: {
            start: new Date(currentYear, currentMonth, 1),
            end: new Date(currentYear, currentMonth + 1, 0)
          },
          metadata: {
            billingType: 'monthly',
            chargeType: 'electricity',
            isAutoGenerated: true
          }
        };

        const invoice = new Invoice(invoiceData);
        await invoice.save();

        console.log(`Electricity bill generated for resident ${resident._id}, amount: ${electricityAmount}`);
      }
    } catch (error) {
      console.error(`Error generating electricity bill for resident ${resident._id}:`, error);
    }
  }

  // Calculate electricity charges (placeholder - integrate with existing system)
  async calculateElectricityCharges(resident) {
    try {
      // This would integrate with your existing ElectricityBill model
      // For now, returning a placeholder amount
      const baseCharge = 200; // Base electricity charge
      const consumptionCharge = Math.floor(Math.random() * 500); // Random consumption
      return baseCharge + consumptionCharge;
    } catch (error) {
      console.error('Error calculating electricity charges:', error);
      return 0;
    }
  }

  // Generate common charges
  async generateCommonCharges(resident) {
    try {
      // Check if common charges are applicable for this PG
      const pgSettings = resident.pgId?.settings || {};
      const commonCharges = pgSettings.commonCharges || 0;

      if (commonCharges > 0) {
        const currentMonth = new Date().getMonth();
        const currentYear = new Date().getFullYear();
        
        const existingBill = await Invoice.findOne({
          tenantId: resident._id,
          type: 'common_charges',
          'billingPeriod.start': {
            $gte: new Date(currentYear, currentMonth, 1),
            $lt: new Date(currentYear, currentMonth + 1, 1)
          }
        });

        if (existingBill) {
          console.log(`Common charges bill already exists for resident ${resident._id} for current month`);
          return;
        }

        const invoiceData = {
          tenantId: resident._id,
          roomId: resident.roomId,
          pgId: resident.pgId,
          type: 'common_charges',
          amount: commonCharges,
          description: `Common charges for ${new Date().toLocaleString('default', { month: 'long', year: 'numeric' })}`,
          dueDate: new Date(Date.now() + (10 * 24 * 60 * 60 * 1000)), // 10 days from now
          billingPeriod: {
            start: new Date(currentYear, currentMonth, 1),
            end: new Date(currentYear, currentMonth + 1, 0)
          },
          metadata: {
            billingType: 'monthly',
            chargeType: 'common_charges',
            isAutoGenerated: true
          }
        };

        const invoice = new Invoice(invoiceData);
        await invoice.save();

        console.log(`Common charges bill generated for resident ${resident._id}, amount: ${commonCharges}`);
      }
    } catch (error) {
      console.error(`Error generating common charges for resident ${resident._id}:`, error);
    }
  }

  // Check overdue payments and take action
  async checkOverduePayments() {
    try {
      const sevenDaysAgo = new Date(Date.now() - (7 * 24 * 60 * 60 * 1000));
      const thirtyDaysAgo = new Date(Date.now() - (30 * 24 * 60 * 60 * 1000));

      // Find severely overdue invoices (30+ days)
      const severelyOverdue = await Invoice.find({
        status: 'pending',
        dueDate: { $lt: thirtyDaysAgo }
      }).populate('tenantId pgId');

      // Find moderately overdue invoices (7-30 days)
      const moderatelyOverdue = await Invoice.find({
        status: 'pending',
        dueDate: { $gte: thirtyDaysAgo, $lt: sevenDaysAgo }
      }).populate('tenantId pgId');

      console.log(`Found ${severelyOverdue.length} severely overdue and ${moderatelyOverdue.length} moderately overdue invoices`);

      // Handle severely overdue payments
      for (const invoice of severelyOverdue) {
        await this.handleSeverelyOverduePayment(invoice);
      }

      // Send final notices for moderately overdue
      for (const invoice of moderatelyOverdue) {
        await this.sendFinalNotice(invoice);
      }
    } catch (error) {
      console.error('Error in checkOverduePayments:', error);
    }
  }

  // Handle severely overdue payment
  async handleSeverelyOverduePayment(invoice) {
    try {
      // Import email service
      const { sendEmail } = await import('../modules/email/index.js');
      
      const daysOverdue = Math.ceil((new Date() - invoice.dueDate) / (24 * 60 * 60 * 1000));
      
      const emailData = {
        to: invoice.tenantId?.email,
        subject: `URGENT: Severely Overdue Payment - Invoice ${invoice.invoiceNumber}`,
        template: 'severely-overdue',
        context: {
          tenantName: invoice.tenantId?.name,
          invoiceNumber: invoice.invoiceNumber,
          amount: invoice.amount,
          dueDate: invoice.dueDate.toDateString(),
          daysOverdue,
          pgName: invoice.pgId?.pg_name || 'PG'
        }
      };

      await sendEmail(emailData);
      
      // Log for admin attention
      console.log(`SEVERE OVERDUE ALERT: Invoice ${invoice._id} is ${daysOverdue} days overdue`);
      
      // Could add additional actions like marking for collection, etc.
    } catch (error) {
      console.error(`Error handling severely overdue payment for invoice ${invoice._id}:`, error);
    }
  }

  // Send final notice
  async sendFinalNotice(invoice) {
    try {
      // Import email service
      const { sendEmail } = await import('../modules/email/index.js');
      
      const daysOverdue = Math.ceil((new Date() - invoice.dueDate) / (24 * 60 * 60 * 1000));
      
      const emailData = {
        to: invoice.tenantId?.email,
        subject: `FINAL NOTICE: Payment Due - Invoice ${invoice.invoiceNumber}`,
        template: 'final-notice',
        context: {
          tenantName: invoice.tenantId?.name,
          invoiceNumber: invoice.invoiceNumber,
          amount: invoice.amount,
          dueDate: invoice.dueDate.toDateString(),
          daysOverdue,
          pgName: invoice.pgId?.pg_name || 'PG'
        }
      };

      await sendEmail(emailData);
      console.log(`Final notice sent for invoice ${invoice._id}`);
    } catch (error) {
      console.error(`Error sending final notice for invoice ${invoice._id}:`, error);
    }
  }

  // Stop a specific job
  stopJob(name) {
    const job = this.jobs.get(name);
    if (job) {
      job.stop();
      this.jobs.delete(name);
      console.log(`Stopped job: ${name}`);
    }
  }

  // Stop all jobs
  stopAllJobs() {
    for (const [name, job] of this.jobs) {
      job.stop();
      console.log(`Stopped job: ${name}`);
    }
    this.jobs.clear();
    this.isInitialized = false;
    console.log('All billing scheduler jobs stopped');
  }

  // Get job status
  getJobStatus() {
    const status = {};
    for (const [name, job] of this.jobs) {
      status[name] = {
        running: job.running,
        scheduled: job.scheduled
      };
    }
    return status;
  }

  // Manual trigger for testing
  async triggerJob(jobName) {
    switch (jobName) {
      case 'billing-check':
        await this.checkUpcomingBills();
        break;
      case 'payment-reminders':
        await this.sendPaymentReminders();
        break;
      case 'monthly-billing':
        await this.generateMonthlyBilling();
        break;
      case 'overdue-check':
        await this.checkOverduePayments();
        break;
      default:
        throw new Error(`Unknown job: ${jobName}`);
    }
  }
}

// Create singleton instance
const billingScheduler = new BillingScheduler();

export default billingScheduler;